"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.exportEmbedAsync = exportEmbedAsync;
var _fs = _interopRequireDefault(require("fs"));
var _server = _interopRequireDefault(require("metro/src/Server"));
var _bundle = _interopRequireDefault(require("metro/src/shared/output/bundle"));
var _path = _interopRequireDefault(require("path"));
var _log = require("../../log");
var _instantiateMetro = require("../../start/server/metro/instantiateMetro");
var _resolveFromProject = require("../../start/server/metro/resolveFromProject");
var _nodeEnv = require("../../utils/nodeEnv");
var _forkBundleAsync = require("../fork-bundleAsync");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function exportEmbedAsync(projectRoot, options) {
    (0, _nodeEnv).setNodeEnv(options.dev ? "development" : "production");
    require("@expo/env").load(projectRoot);
    const { config  } = await (0, _instantiateMetro).loadMetroConfigAsync(projectRoot, {
        maxWorkers: options.maxWorkers,
        resetCache: options.resetCache,
        config: options.config
    }, {
        isExporting: true
    });
    const saveAssets = (0, _resolveFromProject).importCliSaveAssetsFromProject(projectRoot);
    let sourceMapUrl = options.sourcemapOutput;
    if (sourceMapUrl && !options.sourcemapUseAbsolutePath) {
        sourceMapUrl = _path.default.basename(sourceMapUrl);
    }
    const bundleRequest = {
        ..._server.default.DEFAULT_BUNDLE_OPTIONS,
        entryFile: options.entryFile,
        sourceMapUrl,
        dev: options.dev,
        minify: !!options.minify,
        platform: options.platform,
        unstable_transformProfile: options.unstableTransformProfile
    };
    const server = new _server.default(config, {
        watch: false
    });
    try {
        const bundle = await server.build({
            ...bundleRequest,
            bundleType: "bundle"
        });
        _fs.default.mkdirSync(_path.default.dirname(options.bundleOutput), {
            recursive: true,
            mode: 493
        });
        // Persist bundle and source maps.
        await _bundle.default.save(bundle, options, _log.Log.log);
        // Save the assets of the bundle
        const outputAssets = await (0, _forkBundleAsync).getAssets(server, {
            ...bundleRequest,
            bundleType: "todo"
        });
        await saveAssets(outputAssets, options.platform, options.assetsDest, options.assetCatalogDest);
    } finally{
        server.end();
    }
}

//# sourceMappingURL=exportEmbedAsync.js.map