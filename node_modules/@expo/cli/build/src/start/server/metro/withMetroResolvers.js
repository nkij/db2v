"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getDefaultMetroResolver = getDefaultMetroResolver;
exports.withMetroResolvers = withMetroResolvers;
var _chalk = _interopRequireDefault(require("chalk"));
var _path = _interopRequireDefault(require("path"));
var _metroErrors = require("./metroErrors");
var _resolveFromProject = require("./resolveFromProject");
var _env = require("../../../utils/env");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const debug = require("debug")("expo:metro:withMetroResolvers");
function getDefaultMetroResolver(projectRoot) {
    const { resolve  } = (0, _resolveFromProject).importMetroResolverFromProject(projectRoot);
    return (context, moduleName, platform)=>{
        return resolve(context, moduleName, platform);
    };
}
function optionsKeyForContext(context) {
    const canonicalize = require("metro-core/src/canonicalize");
    var _customResolverOptions, ref;
    // Compound key for the resolver cache
    return (ref = JSON.stringify((_customResolverOptions = context.customResolverOptions) != null ? _customResolverOptions : {}, canonicalize)) != null ? ref : "";
}
function withMetroResolvers(config, projectRoot, resolvers) {
    var ref4, ref1;
    debug(`Appending ${resolvers.length} custom resolvers to Metro config. (has custom resolver: ${!!((ref4 = config.resolver) == null ? void 0 : ref4.resolveRequest)})`);
    const originalResolveRequest = ((ref1 = config.resolver) == null ? void 0 : ref1.resolveRequest) || getDefaultMetroResolver(projectRoot);
    function mutateResolutionError(error, context, moduleName, platform) {
        var ref;
        if (!_env.env.EXPO_METRO_UNSTABLE_ERRORS || !platform) {
            debug("Cannot mutate resolution error");
            return error;
        }
        const mapByOrigin = depGraph.get(optionsKeyForContext(context));
        const mapByPlatform = mapByOrigin == null ? void 0 : mapByOrigin.get(platform);
        if (!mapByPlatform) {
            return error;
        }
        // collect all references inversely using some expensive lookup
        const getReferences = (origin)=>{
            const inverseOrigin = [];
            if (!mapByPlatform) {
                return inverseOrigin;
            }
            for (const [originKey, mapByTarget] of mapByPlatform){
                // search comparing origin to path
                const found = [
                    ...mapByTarget.values()
                ].find((resolution)=>resolution.path === origin
                );
                if (found) {
                    inverseOrigin.push({
                        origin,
                        previous: originKey,
                        request: found.request
                    });
                }
            }
            return inverseOrigin;
        };
        const pad = (num)=>{
            return new Array(num).fill(" ").join("");
        };
        var ref2, ref3;
        const root = (ref3 = (ref2 = (ref = config.server) == null ? void 0 : ref.unstable_serverRoot) != null ? ref2 : config.projectRoot) != null ? ref3 : projectRoot;
        const recurseBackWithLimit = (req, limit, count = 0)=>{
            const results = {
                origin: req.origin,
                request: req.request,
                previous: []
            };
            if (count >= limit) {
                return results;
            }
            const inverse = getReferences(req.origin);
            for (const match of inverse){
                // Use more qualified name if possible
                // results.origin = match.origin;
                // Found entry point
                if (req.origin === match.previous) {
                    continue;
                }
                results.previous.push(recurseBackWithLimit({
                    origin: match.previous,
                    request: match.request
                }, limit, count + 1));
            }
            return results;
        };
        const inverseTree = recurseBackWithLimit({
            origin: context.originModulePath,
            request: moduleName
        }, // TODO: Do we need to expose this?
        35);
        if (inverseTree.previous.length > 0) {
            debug("Found inverse graph:", JSON.stringify(inverseTree, null, 2));
            let extraMessage = _chalk.default.bold("Import stack:");
            const printRecursive = (tree, depth = 0)=>{
                let filename = _path.default.relative(root, tree.origin);
                if (filename.match(/\?ctx=[\w\d]+$/)) {
                    filename = filename.replace(/\?ctx=[\w\d]+$/, _chalk.default.dim(" (require.context)"));
                } else {
                    let formattedRequest = _chalk.default.green(`"${tree.request}"`);
                    if (// If bundling for web and the import is pulling internals from outside of react-native
                    // then mark it as an invalid import.
                    platform === "web" && !/^(node_modules\/)?react-native\//.test(filename) && tree.request.match(/^react-native\/.*/)) {
                        formattedRequest = formattedRequest + _chalk.default`\n          {yellow Importing react-native internals is not supported on web.}`;
                    }
                    filename = filename + _chalk.default`\n{gray  |} {cyan import} ${formattedRequest}\n`;
                }
                let line = "\n" + pad(depth) + _chalk.default.gray(" ") + filename;
                if (filename.match(/node_modules/)) {
                    line = _chalk.default.gray(// Bold the node module name
                    line.replace(/node_modules\/([^/]+)/, (_match, p1)=>{
                        return "node_modules/" + _chalk.default.bold(p1);
                    }));
                }
                extraMessage += line;
                for (const child of tree.previous){
                    printRecursive(child, // Only add depth if there are multiple children
                    tree.previous.length > 1 ? depth + 1 : depth);
                }
            };
            printRecursive(inverseTree);
            // @ts-expect-error
            error._expoImportStack = extraMessage;
        } else {
            debug("Found no inverse tree for:", context.originModulePath);
        }
        return error;
    }
    const depGraph = new Map();
    return {
        ...config,
        resolver: {
            ...config.resolver,
            resolveRequest (context, moduleName, platform) {
                const storeResult = (res)=>{
                    if (!_env.env.EXPO_METRO_UNSTABLE_ERRORS || !platform) return;
                    const key = optionsKeyForContext(context);
                    if (!depGraph.has(key)) depGraph.set(key, new Map());
                    const mapByTarget = depGraph.get(key);
                    if (!mapByTarget.has(platform)) mapByTarget.set(platform, new Map());
                    const mapByPlatform = mapByTarget.get(platform);
                    if (!mapByPlatform.has(context.originModulePath)) mapByPlatform.set(context.originModulePath, new Set());
                    const setForModule = mapByPlatform.get(context.originModulePath);
                    const qualifiedModuleName = (res == null ? void 0 : res.type) === "sourceFile" ? res.filePath : moduleName;
                    setForModule.add({
                        path: qualifiedModuleName,
                        request: moduleName
                    });
                };
                const universalContext = {
                    ...context,
                    preferNativePlatform: platform !== "web"
                };
                try {
                    for (const resolver of resolvers){
                        try {
                            const resolution = resolver(universalContext, moduleName, platform);
                            if (resolution) {
                                storeResult(resolution);
                                return resolution;
                            }
                        } catch (error) {
                            // If no user-defined resolver, use Expo's default behavior.
                            // This prevents extraneous resolution attempts on failure.
                            if (!config.resolver.resolveRequest) {
                                throw error;
                            }
                            // If the error is directly related to a resolver not being able to resolve a module, then
                            // we can ignore the error and try the next resolver. Otherwise, we should throw the error.
                            const isResolutionError = (0, _metroErrors).isFailedToResolveNameError(error) || (0, _metroErrors).isFailedToResolvePathError(error);
                            if (!isResolutionError) {
                                throw error;
                            }
                            debug(`Custom resolver threw: ${error.constructor.name}. (module: ${moduleName}, platform: ${platform})`);
                        }
                    }
                    // If we haven't returned by now, use the original resolver or upstream resolver.
                    const res = originalResolveRequest(universalContext, moduleName, platform);
                    storeResult(res);
                    return res;
                } catch (error) {
                    throw mutateResolutionError(error, universalContext, moduleName, platform);
                }
            }
        }
    };
}

//# sourceMappingURL=withMetroResolvers.js.map